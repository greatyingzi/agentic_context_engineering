# ğŸ¯ è¯„åˆ†æœºåˆ¶æ·±åº¦åˆ†æä¸é‡æ„æ–¹æ¡ˆ

## ğŸ“Š å½“å‰æœºåˆ¶çš„é—®é¢˜è¯Šæ–­

### âŒ æ ¸å¿ƒé—®é¢˜

1. **è¯„åˆ†ç²’åº¦ç²—ç³™**
   - åªæœ‰ä¸¤æ¡£ï¼š+1ï¼ˆhelpfulï¼‰vs -3ï¼ˆharmfulï¼‰
   - æ— æ³•è¡¨è¾¾"éƒ¨åˆ†æœ‰ç”¨"ã€"ç•¥æœ‰é£é™©"ç­‰ä¸­é—´çŠ¶æ€
   - ç¼ºä¹è¯­ä¹‰ç»´åº¦çš„è¯„ä¼°

2. **æƒé‡ä¸å¯¹ç§°**
   - å¸®åŠ©ï¼š+1ï¼Œä¼¤å®³ï¼š-3ï¼ˆ3å€å·®è·ï¼‰
   - è¿‡åˆ†æƒ©ç½šé”™è¯¯ï¼Œç¼ºä¹å¹³è¡¡

3. **æ¸©åº¦ç»“åˆç²—ç³™**
   - ç®€å•çº¿æ€§ä¹˜æ³•ï¼š`(2.0-temp)` å’Œ `tempÃ—1.5`
   - æ²¡æœ‰è€ƒè™‘kptçš„é£é™©ç‰¹å¾
   - é«˜æ¸©æ—¶é«˜é£é™©kptæƒé‡è¿‡é«˜

4. **è¯„åˆ†æ—¶æœºæ™š**
   - kptåˆ›å»ºåé€šè¿‡reflectionè¯„åˆ†
   - ç¼ºä¹æå–æ—¶çš„å³æ—¶é£é™©è¯„ä¼°

---

## ğŸš€ é‡æ„æ–¹æ¡ˆï¼šå¤šç»´åº¦è¯­ä¹‰è¯„åˆ†ç³»ç»Ÿ

### ğŸ“ æ–°è¯„åˆ†ç»´åº¦è®¾è®¡

#### 1. **åŸºç¡€è¯„åˆ†** (-1.0 ~ 1.0)
```json
{
  "effectiveness": 0.8,     // æœ‰æ•ˆæ€§ï¼š0-1ï¼Œè¡¡é‡å®é™…æ•ˆæœ
  "risk_level": -0.3,       // é£é™©åº¦ï¼š-1-0ï¼Œè´Ÿå€¼è¡¨ç¤ºé£é™©
  "innovation": 0.2,        // åˆ›æ–°æ€§ï¼š0-1ï¼Œè¡¡é‡æ–°é¢–ç¨‹åº¦
  "complexity": 0.5         // å¤æ‚åº¦ï¼š0-1ï¼Œå®æ–½éš¾åº¦
}
```

#### 2. **ç»¼åˆè¯„åˆ†å…¬å¼**
```python
def calculate_semantic_score(dimensions):
    """è®¡ç®—è¯­ä¹‰ç»¼åˆè¯„åˆ†"""
    return {
        "core_score": dimensions["effectiveness"] - abs(dimensions["risk_level"]),
        "risk_profile": dimensions["risk_level"],
        "innovation_factor": dimensions["innovation"],
        "complexity": dimensions["complexity"],
        "temperature_sensitivity": dimensions["innovation"] * (1 + dimensions["risk_level"])
    }
```

### ğŸŒ¡ï¸ æ¸©åº¦æ™ºèƒ½ç»“åˆç³»ç»Ÿ

#### åˆ†æ®µæ¸©åº¦æƒé‡ï¼ˆå–ä»£çº¿æ€§ï¼‰
```python
def temperature_weighting(score_profile, temperature):
    """åˆ†æ®µæ¸©åº¦æƒé‡è®¡ç®—"""
    core = score_profile["core_score"]
    risk = score_profile["risk_profile"]
    innovation = score_profile["innovation_factor"]

    if temperature <= 0.3:  # ä¿å®ˆæ¨¡å¼
        # é«˜æƒé‡ï¼šä½é£é™©ã€é«˜æœ‰æ•ˆæ€§
        return {
            "multiplier": 2.5 + abs(risk) * 2,
            "risk_penalty": risk * temperature * 3
        }
    elif temperature <= 0.7:  # å¹³è¡¡æ¨¡å¼
        # å¹³è¡¡è€ƒè™‘å„ç»´åº¦
        return {
            "multiplier": 1.5 + innovation,
            "risk_penalty": risk * temperature * 1.5
        }
    else:  # æ¢ç´¢æ¨¡å¼
        # é¼“åŠ±åˆ›æ–°ï¼Œä½†æ§åˆ¶é£é™©
        return {
            "multiplier": 1.0 + innovation * 2,
            "risk_penalty": risk * temperature * 0.5
        }
```

### ğŸ” kptæå–æ—¶å³æ—¶è¯„åˆ†

#### æ–°çš„æå–promptè®¾è®¡
```prompt
# åœ¨kptæå–æ—¶å³æ—¶è¯„ä¼°ç»´åº¦
For each extracted key point, evaluate:
- effectiveness (0.0-1.0): How well does this work in practice?
- risk_level (-1.0-0.0): What are the risks/limitations?
- innovation (0.0-1.0): How novel/experimental is this?
- complexity (0.0-1.0): How hard is this to implement?

Examples:
"Add index to slow queries" -> {effectiveness: 0.9, risk_level: -0.1, innovation: 0.1, complexity: 0.2}
"Use quantum cryptography" -> {effectiveness: 0.3, risk_level: -0.9, innovation: 0.9, complexity: 0.8}
```

### ğŸ¯ æ™ºèƒ½åˆ é™¤ä¸è¿‡æ»¤ç³»ç»Ÿ

#### å¤šå±‚æ¬¡è¿‡æ»¤ç­–ç•¥
```python
def intelligent_kpt_filtering(kpts, temperature, context):
    """æ™ºèƒ½kptè¿‡æ»¤"""
    filtered = []

    for kp in kpts:
        profile = kp["semantic_score"]

        # ç¡¬è¿‡æ»¤ï¼šæåº¦é«˜é£é™©
        if profile["risk_profile"] < -0.8 and temperature < 0.8:
            continue  # ä½æ¸©æ—¶è¿‡æ»¤æé«˜é£é™©é¡¹

        # åŠ¨æ€è¿‡æ»¤ï¼šåŸºäºæ¸©åº¦è°ƒæ•´
        risk_threshold = -0.5 + temperature * 0.7  # -0.5 to 0.2

        if profile["risk_profile"] < risk_threshold:
            continue

        filtered.append(kp)

    return filtered
```

---

## ğŸ“Š æ–°æœºåˆ¶å¯¹æ¯”åˆ†æ

### ğŸ­ åœºæ™¯ç¤ºä¾‹å¯¹æ¯”

| kpt | æ—§è¯„åˆ† | æ–°è¯­ä¹‰è¯„åˆ† | Temp=0.1æƒé‡ | Temp=0.9æƒé‡ |
|-----|--------|-----------|-------------|-------------|
| "æ·»åŠ ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢" | 4 | {E:0.9,R:-0.1,I:0.1,C:0.2} | 2.6x | 1.3x |
| "é‡å­åŠ å¯†é€šä¿¡" | -2 | {E:0.3,R:-0.9,I:0.9,C:0.8} | 0.1x | 2.8x |
| "å¾®æœåŠ¡æ‹†åˆ†" | 1 | {E:0.6,R:-0.4,I:0.5,C:0.7} | 1.2x | 1.9x |

### ğŸ“ˆ æ”¹è¿›æ•ˆæœ

1. **ç²¾ç»†æ§åˆ¶**ï¼šä»9çº§æ•´æ•°å˜ä¸ºè¿ç»­æµ®ç‚¹
2. **è¯­ä¹‰æ„ŸçŸ¥**ï¼šè€ƒè™‘é£é™©ã€åˆ›æ–°ã€å¤æ‚åº¦
3. **æ™ºèƒ½è¿‡æ»¤**ï¼šä½æ¸©æ—¶è‡ªåŠ¨è¿‡æ»¤é«˜é£é™©é¡¹
4. **æ¸©åº¦æ•æ„Ÿ**ï¼šä¸åŒæ¸©åº¦ä¸‹è¡¨ç°å·®å¼‚æ›´æ˜æ˜¾

---

## ğŸš€ å®æ–½è·¯çº¿å›¾

### Phase 1: åŸºç¡€æ”¹è¿›ï¼ˆç«‹å³å¯è¡Œï¼‰
1. æ‰©å±•è¯„åˆ†åˆ°-5~+5çš„æ•´æ•°èŒƒå›´
2. æ·»åŠ "moderately_useful" (+2) å’Œ "slightly_harmful" (-1)
3. æ”¹è¿›æ¸©åº¦æƒé‡ä¸ºåˆ†æ®µå‡½æ•°

### Phase 2: è¯­ä¹‰å‡çº§ï¼ˆä¸­æœŸç›®æ ‡ï¼‰
1. å®ç°å¤šç»´åº¦è¯­ä¹‰è¯„åˆ†
2. kptæå–æ—¶å³æ—¶è¯„ä¼°
3. æ™ºèƒ½è¿‡æ»¤ç³»ç»Ÿ

### Phase 3: è‡ªé€‚åº”ä¼˜åŒ–ï¼ˆé•¿æœŸç›®æ ‡ï¼‰
1. åŸºäºç”¨æˆ·åé¦ˆå­¦ä¹ è¯„åˆ†
2. åŠ¨æ€è°ƒæ•´æ¸©åº¦æ•æ„Ÿåº¦
3. ä¸ªæ€§åŒ–è¯„åˆ†ç­–ç•¥

---

## ğŸ¯ ç«‹å³å¯å®æ–½çš„æ”¹è¿›

### æœ€å°æ”¹åŠ¨æ–¹æ¡ˆ
```python
# å½“å‰ï¼šhelpful=+1, harmful=-3
# æ”¹è¿›ï¼š5çº§è¯„åˆ†
RATING_MAP = {
    "highly_effective": +3,    # æ•ˆæœæ˜¾è‘—
    "moderately_useful": +2,   # ä¸­ç­‰æœ‰ç”¨
    "slightly_useful": +1,     # è½»å¾®æœ‰ç”¨
    "neutral": 0,              # ä¸­æ€§
    "slightly_harmful": -1,    # è½»å¾®æœ‰å®³
    "moderately_harmful": -2,   # ä¸­ç­‰æœ‰å®³
    "highly_dangerous": -4      # æåº¦å±é™©
}

# åˆ†æ®µæ¸©åº¦æƒé‡
def piecewise_temperature_weight(kp_score, temperature):
    if kp_score >= 2:  # é«˜åˆ†kpt
        if temperature <= 0.3:
            return 2.5 - temperature * 0.5
        elif temperature <= 0.7:
            return 2.0 - temperature * 0.8
        else:
            return 1.5 - temperature * 0.5
    elif kp_score >= 0:  # ä¸­ç­‰kpt
        return 0.8 + temperature * 0.4
    else:  # è´Ÿåˆ†kpt
        if temperature <= 0.3:
            return -2.0  # ä½æ¸©æ—¶ä¸¥é‡æƒ©ç½š
        elif temperature <= 0.7:
            return temperature - 0.5
        else:
            return temperature * 0.8
```

è¿™æ ·çš„æ”¹è¿›èƒ½ç«‹å³æå‡è¯„åˆ†çš„ç²’åº¦å’Œæ¸©åº¦çš„æ•æ„Ÿæ€§ï¼